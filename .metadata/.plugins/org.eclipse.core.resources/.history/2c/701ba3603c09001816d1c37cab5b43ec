package org.usfirst.team4145.robot.shared;

import edu.wpi.first.wpilibj.I2C;

public class APDS_9960V2 {
	
	private I2C apds;
	
	//registers
	private byte ENABLE = (byte) 0x80;
	private byte ATIME = (byte) 0x81;
	private byte WTIME = (byte) 0x83;
	//private byte AILTL = (byte) 0x84;
	//private byte AILTH = (byte) 0x85;
	//private byte AIHTL = (byte) 0x86;
	//private byte AIHTH = (byte) 0x87;
	private byte PERS = (byte) 0x8C;
	private byte CONFIG1 = (byte) 0x8D;
	private byte CONTROL = (byte) 0x8F;
	private byte CONFIG2 = (byte) 0x90;
	private byte STATUS = (byte) 0x93;
	private byte CDATAL = (byte) 0x94;
	private byte CDATAH = (byte) 0x95;
	private byte RDATAL = (byte) 0x96;
	private byte RDATAH = (byte) 0x97;
	private byte GDATAL = (byte) 0x98;
	private byte GDATAH = (byte) 0x99;
	private byte BDATAL = (byte) 0x9A;
	private byte BDATAH = (byte) 0x9B;
	private byte CICLEAR = (byte) 0xE5;
	private byte AICLEAR = (byte) 0xE7;
	
	public APDS_9960V2() {
		apds = new I2C(I2C.Port.kOnboard,0x39);
	}
		
	public void init() throws Exception {
		byte[] verify = new byte[1];
		if (apds.read(0x92, 1, verify)) {
			if (verify[0] != (byte) 0xAB || verify[0] != (byte) 0x9C) {
				throw new Exception(
						"Device ID Mismatch - Wrong ID in register 0x92 - check to see if the bus is configured correctly!");
			}
		}
		if(apds.write(ENABLE, 01111000)) {
			throw new Exception("Failed to Write Enable register");
		}
		if(apds.write(ATIME,11111111)) {
			throw new Exception("Failed to write Integration time register");
		}
		if(apds.write(WTIME, 11111111)) {
			throw new Exception("Failed to write wait time register");
		}
		if(apds.write(PERS, 00000000)) {
			throw new Exception("Failed to set persistence register");
		}
		if(apds.write(CONFIG1, 01000110)) {
			throw new Exception("Failed to set config1 register");
		}
		if(apds.write(CONTROL, 01000000)) {
			throw new Exception("Failed to set Control register");
		}
		if(apds.write(CONFIG2, 10000010)) {
			throw new Exception("Failed to set Config2 register");
		}
		if(clearInterupts()) {
			throw new Exception("Failed to clear Interupts BEFORE init");
		}
	}
	
	public int[] getColorData() throws Exception {
		int[] out = new int[4];
		if(getColorArray(out)) {
			throw new Exception("Failed to read color data");
		}
		//if(!clearInterupts()) {
			//throw new Exception("Failed to clear Interupts after init");
		//}
		return out;
	}
	
	public boolean clearInterupts() {
		if(apds.write(CICLEAR, 10000000)) {
			return false;
		}
		if(apds.write(AICLEAR, 10000000)) {
			return false;
		}
		return true;
	}
	
	private boolean getRed(int out) {
		byte[] outr = new byte[2];
		if (apds.read(RDATAL, 2, outr)) {
			return false;
		}
		out = outr[1] << 8;
		out += outr[0];
		System.out.println(out + " " + outr[0] + " " + outr[1]);
		return true;

	}

	private boolean getBlue(int out) {
		byte[] outr = new byte[2];
		if (apds.read(BDATAL, 2, outr)) {
			return false;
		}
		out = outr[1] << 8;
		out += outr[0];
		System.out.println(out + " " + outr[0] + " " + outr[1]);
		return true;

	}

	private boolean getGreen(int out) {
		byte[] outr = new byte[2];
		if (apds.read(GDATAL, 2, outr)) {
			return false;
		}
		out = outr[1] << 8;
		out += outr[0];
		System.out.println(out + " " + outr[0] + " " + outr[1]);
		return true;

	}

	private boolean getClear(int out) {
		byte[] outr = new byte[2];
		if (apds.read(CDATAL, 2, outr)) {
			return false;
		}
		out = outr[1] << 8;
		out += outr[0];
		System.out.println(out + " " + outr[0] + " " + outr[1]);
		return true;

	}

	private boolean getColorArray(int[] Name) {
		if (getRed(Name[0]))
			return false;
		if (getGreen(Name[1]))
			return false;
		if (getBlue(Name[2]))
			return false;
		if (getClear(Name[3]))
			return false;
		return true;
	}

}
